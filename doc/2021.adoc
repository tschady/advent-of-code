= Advent of Code 2021
:author: @tschady
:toc:
:toc-placement!:
:date: 2021 Dec 01
:description: Commentary on solutions to http://adventofcode.com/2021[Advent of Code 2021]
:sectanchors:
:stem:

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

My running commentary on approach, with any code of interest.

== Rules for Sanity

1. Never stay up for problem release.
1. Don't sweat the leaderboard.
1. Finish puzzle and refactor before looking at other approaches.

toc::[]

== link:../src/aoc/2021/d01.clj[aoc.2021.d01]
The trick here is realizing that `(B + C + D) - (A + B + C) = D - A`.
I originally used the 3-arity version of map with
`(count (filter pos? (map - (rest input) input)))`
but then realized that was a utility fn I'd forgotten about: `intervals`, for
the speed competition I never enter.

[source, clojure]
----
(defn part-1 [input]
  (count (filter pos? (intervals input))))

(defn part-2 [input]
  (count (filter pos? (intervals 3 input))))
----


== link:../src/aoc/2021/d04.clj[aoc.2021.d04]
I used 2D arrays for cards and `nil` to mark numbers.
I thought `(group-by bingo?)` worked well, but the main point of interest is
the lazy sequence of recursive calls to `scores`. This sets up the elegant
`part-1`, `part-2` solution, which reads like the problem description.

[source, clojure]
----
(defn scores [[[num & nums] cards]]
  (lazy-seq
   (when num
     (let [{winners true remain nil} (->> cards
                                         (mark-all-cards num)
                                         (group-by bingo?))
           win-scores (map (partial score num) winners)]
       (concat win-scores (scores [nums remain]))))))

(defn part-1 [input] (first (scores (parse-input input))))

(defn part-2 [input] (last (scores (parse-input input))))
----


== link:../src/aoc/2021/d05.clj[aoc.2021.d05]
I use slope and y-intercept to compute points on the line. The interesting part is
use of Infinity: `##Inf` which works well mathematically, but does require the occasional 'if'.

[source, clojure]
----
(defn- slope [[[x1 y1] [x2 y2]]]
  (if (= x2 x1)
    ##Inf
    (/ (- y2 y1) (- x2 x1))))
----


This lets me describe horizontal/vertical/diagonal lines by their slope.

[source, clojure]
----
(defn part-2 [input] (solve #{0 ##Inf 1 -1} input))
----


== link:../src/aoc/2021/d06.clj[aoc.2021.d06]
Simple `iterate` on an 8-element vector of rolled-up fish counts per time.
I saw some solutions that completely destructured the `timers` vector.
This is clever - I never think of it - I don't know why.

[source, clojure]
----
(defn next-gen [timers]
  (let [spawners (get timers 0 0)]
    (-> timers
        (subvec 1)
        (assoc 8 spawners)
        (update 6 (fnil + 0) spawners))))
----


== link:../src/aoc/2021/d07.clj[aoc.2021.d07]
Like many of these AOC problems, a HOF is a clean way to separate part-1 and
part-2 formulas.

[source, clojure]
----
(defn total-fuel
  "Returns the total fuel used by all the crabs at locations `locs` to reach point `dest`,
  using function `f` to compute fuel required for each distance."
  [locs f dest]
  (reduce + (map (comp f #(Math/abs (- ^int % ^int dest))) locs)))
----


For part 1, because the costs are linear with distance, we know the median will be the meeting point.

[source, clojure]
----
(defn part-1 [input]
  (total-fuel input identity (m/median input)))
----


For part 2, if the fuel formula was `n^2` then the mean would yield the exact answer.
But since formula is a triangle number, which is always less than the square, I first used the mean as an upper bound to reduce the search space.
Then I found
https://www.reddit.com/r/adventofcode/comments/rawxad/2021_day_7_part_2_i_wrote_a_paper_on_todays/[this beauty]
which shows the answer will be within 0.5 of the mean, so I test the 2 integers around it.

[source, clojure]
----
(defn part-2 [input]
  (let [mean (m/mean input)
        low (int (Math/floor mean))
        hi (int (Math/ceil mean))]
    (->> (range low (inc hi))
         (map (partial total-fuel input m/series-sum))
         (apply min))))
----


== link:../src/aoc/2021/d08.clj[aoc.2021.d08]
For this problem I used a combination of expected frequencies of the whole,
and differences between the characters.

- we recognize 1,4,7,8 from their unique string sizes
- we know {b e f} from their unique freqs in the full set of numbers
- we know {a} from diff of 1 and 7
- we know {c} because it's the unknown remaining in 1
- we know {d} because it's the only unknown left in 4
- we know {g} because it's last

I also wrote a handy string diff function that returns a 3-tuple of [only left, only right, common] modeled after `core.data/diff`

[source, clojure]
----
(defn determine-output [[digits outputs]]
  (let [[one seven four & _] (sort-by count digits)
        all-freq (frequencies (apply str digits))
        b (key-for-val all-freq 6)
        e (key-for-val all-freq 4)
        f (key-for-val all-freq 9)
        a (ffirst (diff seven one))
        c (ffirst (diff one #{f}))
        d (ffirst (diff four #{b c f}))
        g (ffirst (diff "abcdefg" #{a b c d e f}))
        subst-map {a \a b \b c \c d \d e \e f \f g \g}]
    (->> outputs
         (map (comp alphagram (partial replace subst-map)))
         (map #(.indexOf all %))
         str/join
         Long/parseLong)))
----


== link:../src/aoc/2021/d09.clj[aoc.2021.d09]
A straightforward problem.  Notably, I was able to reuse my `grid` library
to build the grid, find neighbors, and create the graph in the form of an adjacency map.

[source, clojure]
----
(defn part-2 [input]
  (let [grid (g/build-grid input #(Character/getNumericValue %))]
    (->> (filter (partial low-point? grid) grid)
         (map first)
         (map (partial g/connected-adjacency-map (partial basin? grid) g/neighbor-coords-news))
         (map count)
         (sort >)
         (take 3)
         (reduce *))))
----


== link:../src/aoc/2021/d11.clj[aoc.2021.d11]
The core `step` function used in `iterate`.  By iterating, we do not need to
track any intermediate state like the zero count since we can sum over all the
states reached.

[NOTE]
====
My approach to these problems is to start from the outside in.  In this case,
I typed `(reduce flash grid flashers)` before anything else.
====

[source, clojure]
----
(defn step [grid]
  (loop [grid (transform [MAP-VALS] inc grid)]
    (if-let [flashers (seq (filter #(> (val %) 9) grid))]
      (recur (reduce flash grid flashers))
      grid)))
----


== link:../src/aoc/2021/d12.clj[aoc.2021.d12]
This problem immediately looked like a recursive Depth First Search.
For part-1 I could track the typical visited nodes and remove them from
the next search level, but interestingly part-2 flipped this on its head
and used a variable count.  This could be tracked with an extra boolean
like `bonus-used?`, but I preferred to put this complexity in the data layer
with the allowances map below.

[source, clojure]
----
(defn dfs-paths [g goal path allowances]
  (let [curr (peek path)]
    (if (= goal curr)
      (vector path)
      (let [nexts (filter #(pos? (get allowances %)) (get g curr))]
        (mapcat #(dfs-paths g goal (conj path %) (update allowances curr dec)) nexts)))))
----


The interesting part of the algorithm is this map of the number of times
each cave may be visited.  I use infinity again for large cave count since it can be decremented forever.

[source, clojure]
----
(defn make-allowances
  "Returns map of cave to number of times it may be visited.
  Small caves begin with lowercase and can be visited once.
  Large caves (everything not small) can be visited infinitely."
  [g]
  (let [{small true, big false} (group-by small-cave? (keys g))]
    (merge (zipmap small (repeat 1)) (zipmap big (repeat ##Inf)))))
----


I optimized for dev time and DFS algo simplicity here, by iterating over
the collection of small-caves, treating each one in turn as
the magic cave that can be visited twice.  There is a lot of duplication here,
with many paths visited multiple times then collpased with `set`.

[source, clojure]
----
(defn part-2 [input]
  (let [g           (parse-graph input)
        init-allow  (make-allowances g)
        small-caves (remove #{"start" "end"} (filter small-cave? (keys g)))]
    (->> small-caves
         (map #(update init-allow % inc))
         (mapcat (partial dfs-paths g "end" ["start"]))
         set
         count)))
----


== link:../src/aoc/2021/d13.clj[aoc.2021.d13]
Great use of specter here to perform a complex conditional mutation.
Thanks to @drowsy for the idea

[source, clojure]
----
(defn fold [paper [axis v]]
  (set (transform [ALL (if (= 'x axis) FIRST LAST) (pred> v)] #(- (* 2 v) %) paper)))
----


== link:../src/aoc/2021/d14.clj[aoc.2021.d14]
For part-1, I raced to an iterative solution building the string each time with
`medley.core/interleave-all`.
10 iterations took 20ms, 20 took 1000x that, so there's no way we can do this 40 times.
Looking at the ruleset, it's pretty contained, so we should be able to just track
counts of each pair.  Very similar to day 6 for fish count.

[source, clojure]
----
(defn step [rules pair-counts]
  (reduce-kv (fn [m [a b :as k] v]
               (let [insert (get rules k)]
                 (-> m
                     (update [a insert] (fnil + 0) v)
                     (update [insert b] (fnil + 0) v))))
             {}
             pair-counts))
----


The only thing of interest here is `x-nth`, a utility function I wrote that just
reverses the arguments of `nth` in order to make thread-last work.

[source, clojure]
----
(defn solve [input n]
  (let [[orig rules] (parse input)]
    (->> orig
         (partition 2 1)
         frequencies
         (iterate (partial step rules))
         (x-nth n)
         (assemble (last orig))
         score)))
----


== link:../src/aoc/2021/d15.clj[aoc.2021.d15]
First graph problem of the year.

[IMPORTANT]
====
(Is your https://www.reddit.com/r/adventofcode/comments/k3q7tr/my_advent_of_code_2020_bingo_card_fun_little_side/[AdventOfCode bingo card] complete yet?)
====

You *could* type out Dijkstra's algorithm, using Java's PriorityQueue
or `clojure.data.priority-map`.  Or, you could just slam it all into
a graph library and Keep 'er Movin'.

My go-to for these is https://github.com/Engelberg/ubergraph[ubergraph].
There was some ambiguity in the constructor for edges
(since the nodes were also `[x y]` vectors),
so I had to build an empty graph and use the explicit `add-edges*`

[source, clojure]
----
(defn edges [risks]
  (for [loc      (keys risks)
        neighbor (grid/neighbor-coords-news loc)
        :let     [risk (get risks neighbor)]
        :when    (some? risk)]
    [loc neighbor {:weight risk}]))

(defn safest-path [risk-grid start end]
  (-> (uber/multidigraph)
      (uber/add-edges* (edges risk-grid))
      (alg/shortest-path start end :weight)))
----


Part 2 is solved the same way after expanding the grid.
My new `mod-1` function helps prevent off-by-ones with 1-based indexing.

[source, clojure]
----
(defn expand-grid [grid magnifier]
  (let [[width height] (grid/size grid)]
    (apply merge (for [loc (keys grid)
                       dx   (range magnifier)
                       dy   (range magnifier)
                       :let [[x y] loc
                             risk (get grid loc)
                             new-risk (mod-1 (+ dx dy risk) 9)]]
                   {[(+ x (* width dx)) (+ y (* height dy))] new-risk}))))
----


Expanding the grid with size 1 for part-1 in an expensive no-op,
but I'm a sucker for generalizing the two parts.

[source, clojure]
----
(defn solve [input magnifier]
  (let [g (-> input
              (grid/build-grid #(Character/digit % 10))
              (expand-grid magnifier))
        end (mapv dec (grid/size g))]
    (:cost (safest-path g [0 0] end))))

(defn part-1 [input] (solve input 1))

(defn part-2 [input] (solve input 5))
----


== link:../src/aoc/2021/d16.clj[aoc.2021.d16]
This problem was tedious and painful.  I considered BNF parsing
(but the branching is pretty complex), and Java ByteBuffers,
before just settling on plain old Clojure.
The _only_ thing I like about this code is my use of `cl-format`.

[source, clojure]
----
(defn hex->bits [hex]
  (cl-format nil "船О漫磲（描狎徙翦虔溟玳倍桢┅娱钽犰翳轶溽翎轶轫眭翎忪瀣犰镦翳弩囿扉沐骖翎脲轭篝蝈犴犷蝈趱蝾趱痨镦翳翎蜱弭鲠祯犷翳篝蝈犴鏖翳翳翎蜱弭蝈盹鲥洚娱眭灬翦溴篝蝓泗轹汨镯痖铉怩轸轶徕箫祯翦禊铒骢町垠秕蜚瀣沆镪躜遢ㄤ彐箪殂瀛鲠垲篝蝈犴戾圹篚怅篝蝈犴箴扉舡狒篝蝈犴┹郇蟓鹃铘篚怅篝蝈犴荸囗邃戾泔蝈翎脲躔麸筢鲥箫礤糸礤腩秣轭麒孱麸篝镳汨镯痖铉翳忾趔垠秕蜚瀣沆镪躜遢ㄤ彐箪殂瀛扉翦蜥垠趄遽磔戾埚犰疳螋ō揪篝蝈犴疳螋轸轱旦翎脲躔麸（馨ㄦ轵篝ォ┅篝蝈犴ㄤ蝻ㄣ秕铘ㄦ灬趑孱鲠飙疳螋┅篝蝈犴鲠祯ō揪鲠飙疳螋磲疳螋獒潋镳暴骒狒翦蟓鹃铘博┹埚犰蹂篝蝈犴荸澡磲轭祜镳轶纤垠秕蜚瀣沆镪躜遢ㄤ彐疳蝮瀛疳汶弭垠趄遽磔戾圹鲥蝮轱篝蝈犴箪殂瀛鲠篝蝈犴埕疱篝蝈犴箪殂瀛鲠篝蝈犴垧狴祜徜篝蝈犴ㄣ狍豉疱箪殂瀛扉翦蜥篝蝈犴箪殂瀛镳弪狒矧篝蝈犴┅埯忽弪箝镱鲥蝮轱呼疱豉疱吼狴祜徜疳祜徜篝蝈犴荸歪痧轭麸骢钽糸镱磲脲翳泔溴蝈徜徕戾垠秕蜚瀣沆镪躜遢ㄤ彐豉疱撅黹磲（殒ケゲ癌（殒ケゲ癌（殒ケゲ癌ㄤ彐弼犰踽翦埯弘妁埕疱疳祜徜蔟ㄩ豉疱疳祜徜蝈漉沐豉疱撅豉疱磲弼犰踽翦疳祜徜┅┅浇扉铍寒篁惘犸惘舶脖浔樊沆贳犸惝舶脖浔份王汨盹蝈骢痱镡戾怼惋蝈翳轭腴铉戾篌豉痖铉骑疳螋爆麇腩秣翳痱镡鏖祆蝈趱蝾麸屮徙綮帙桨狒箫礤圄忮汜躞镦簌眄弭蝙箫翳磲鲥祜汩豉鏖祆忮麒狒弼弪忉蝈禊骈趔轭翳怙狒翳铄篝屦垠秕蜚瀣沆镪躜遢ㄤ彐疳螋圹咻箦蜷弩篚ㄤ邈ㄍ狒璇徕癌┅洛汜躞澍漪薏轶篝屦骢钽糸镱ō爆翳孱篚滗孱禊癌麇箝眇扉纟怡汜痧轭麸麒孱盹糸镱篝镳螽轶豉痖汜飚韵南羼踽糸镱垠秕蜚瀣沆镪躜遢ㄤ彐鲽⒁弭躜翳轭轸獒狲轶鲥祜汩豉麸蝈徙痫轭帏狒糸礤圄喈洛汜躞翳鲥祜汩豉篝镳狒骘蝈鲥颥麇溴翦蝽轭翳狒糸礤鏖翳聃徜蜥糸骘蝽蹯犷汜蝈篚祠翳弪瀹埒糨戾埕喏ㄩ铘ㄍ狒璇蝻躅ㄦ轵篝聃徜蜥糸í┅┅黹暨鲽癌ǒǐí伯í舂í舂í舂┅ㄤ彐鳄⒁弭躜翳轭轸獒狲轶鲥祜汩豉麸蝈徙痫轭帙狒糸礤圄喈垸糨ǒǐǒí伯舂博ㄤ彐鲥飙蜥铉⒁弭躜铙翳蜥铉坼钿痫轭趔镦鲥祜汩糸弩翳狒骈轭翎蜱弭怙铒翦怡囵甙疬编躞轭鲥祜汩豉骢钽糸镱噫狒糸礤圄喈坻垧甙疬陛糨郇轭ㄍ狒璇沐殪ㄦ疬舂┅ㄩ钽ㄩ铘ㄍ狒璇骒镲ㄦ疬舂┅┹澡磲轭狃痱镝汨轶麸疳蜥礤趄辁秭弪圄喈澡轶轶沆矬邃麸箫礤磲圄麒殂麇汜汜煦蹯狒鏖翳翳聃徜蜥糸骘蝽蹯岙娱钽犷盹糸镱轶轭溴疱钿孱衄麇汜汜煦蹯狒翳鲥祜汩豉蜥铉弩翳狒疳篌翳蝻蹒翳翎蜱弭狒遽汨糸礤篝屦垠秕蜚瀣沆镪躜遢ㄤ彐舡磲垧戾垌狲ㄤ邈ㄍ狒璇徕皓┹ㄩ铘ㄦ轵篝聃徜蜥糸íㄩ钽í磲雯┅í皓┅┅ㄤ彐疳螋圹甙弑甙弑葺ㄣ秕铘箦ㄦ矧埕蜥铉ㄩ钽舡磲甙┅ㄡ痧禊蜥铉鲥飙蜥铉鲽埒甙弑舂ㄡ痧禊蜥铉鲥飙蜥铉鳄垸甙弑舂┹埒荸┅浇扉铍寒篁惘犸惘舶脖浔府沆贳犸惝舶脖浔篙往骈蝮翳秕玷麽彘翳弪圄蝈瀛箦襦矧嚆祜牾蝈轲喈组翳犰翳钺鲩玑糸铉铄沐篌狎麇铘鏖翳轲疱蝮领翳秕玷骚驷黹扉狎鏖翳翳屙骝镯泔铙殇弪轭翳彘躞镱痱弼轱躞遽蝮翳轶麽睐骈蝮徙趱犰痱镡戾鏖翳翳屙箫箴孱箫礤糸礤蝈徜轭绠澡孱泔铙殇弪徕戾屮疱蜷礤铘狒轱麸骈珲蝈秕翳钺鲩玑糸镱勖琳陨衔浇浇祜篝栾躜忮汜躞蝈徜翳轭篝蝓泗轱铙黩镱绠麽钺鲩玑糸铉翳蝻蹒翳趄邋骈钿轭翳骈蝮狯衢灬忪镳弪狒轱瞵翳孱滹轭轸澡轭篝蝓泗轱铙筢麸滹犰翳屮痨镤轭绗翳孱顼忉汶犷滹犷箴扉趑轭绠栳麸躞痱轭翩溴怩珑轭镱翳屮犴痨鏖翳黹铄鲶犷雉桢疱蝮镱箫祯糸镱麸箦麒弪麇铘黩镱绠浇浇秋趑祜鲥痱镡戾轭瘐翳狒钺糸鲥渺镪躜泔溴箫囹遽洵篝蜷铉牾篝黠螂螽垠秕蜚瀣沆镪躜遢ㄤ彐轭瘐磲瘀蝈徜篝蜷铉ㄦ殪瀛豸殪蝈徜扉铄⒉安悲浔府豇簪┅伍沐麸栳鲥翳溴痿犰镱骘翳蜷溴垠秕蜚瀣沆镪躜遢ㄤ彐瞽屮痨镤蹇垲镤遢ㄡ钿ㄣ镬炜轲铒溴铒溴┅ㄣ秕铘轲疳翳铒溴┅┅躞犷轸弪狒矧麸灬殪钺鲩玑翦翳趄邋轭翳箴邈殒殄溟蝈泗轱詈囝屮羿骘骘蝼狎浏蜷玷衄囵蝈鲟骘忉汶麽蜾蟑戾骠族铄邃麸轭沆蹁翳轶啜铒铋炜┅汨邈忮汜躞帔轲孱溧镱禊黠螂顼轭骘蝼狎潴阻孱麇顼忉汶麽蜾疳篝翳蝻雉囝殪轶秕翦蝽轭狒轭箝珙犰垠秕蜚瀣沆镪躜遢ㄤ彐轸弪轲埴轲疱篝屦骖ō揪轲疱ㄩ翦蜥翦篝屦骖翎脲麒殪（犷铒铋炜ォ铒轲孱淇ォ┅┅娱钽麇铄邃麸躔溽翦赭屐屙孱趔麇栳鲥麸蝈趱蝾忉汶麸翳轶铒溴镱禊殒麇躔溽翦翳戾骠镱瀹澡躞犷蹒禊腱蹁珏轭翳徜洵戾骠骢钽糸镱麸蝈趱蝾忉汶垠秕蜚瀣沆镪躜遢ㄤ彐屮痨镤埴轲疱蜉戾圹戾骠蜷玷糨轲铒溴轲疱颟ō轲疱轲蝈痨徙癌ㄡ滗戾骠戾骠ㄡ滗蜷玷蜷玷舂轲蝻雉┅ㄤ彐箴扉⒁弭躜铙翳轲疱鏖翳翳轶铒溴蝈痨徙邃怡铄汨殪铒溴澡汨殪潴鲠祯弩狎翳轭翦珏栳祧弩镦翳沲蝌孱鲠祯瀣鏖翳蝻躅溟铉顼轭麸翳蜷玷鲠祯瀹埴轲疱蜉戾垲轲铒溴轲疱颟戾骠聃雉博蜷玷ō戾骠┹ō轲疱轲蝈痨徙垤彐蜷玷糨轲蝻雉┅澡磲轭祜镳躞弩轸弪狒矧麸骈钿翳铄狯衢灬忪屮痨镤弪涉翳弪轶瞌镱瀣翳孱趄犷箴扉舢涉麇滹瞌箴扉衄翳孱麇蝈滹铄韵南澡轶轶沲蝌孱綮轭彐骈汩孱衄狍麇蝈钺鲩玑翦忉汶麸遽汨屮痨镤轭铒溴麒孱麇泔蹯牾篝滹犰翳屮痨镤弪轭趱蝾ǖ骘疳螋博垠秕蜚瀣沆镪躜遢ㄤ彐蝈漉沐箢衢垆狒彷戾埴轲疱ō溽翎轲鲥泗矧轲轸弪ㄩ翦颦轲轲疱轲铄舂ㄩ姝戾坼痨镤弪ㄦ轭洵骈蝮屮痨镤蹇轸弪┹蝈沲ㄥ痨镤屮痨镤弪┅ㄩ姝戾垠痨轸翦ㄦ轭洵骈蝮箴扉艨轸弪┹蝈沲箴扉箴扉趑弪┅轲蝻雉轲疱颟┅┅浇扉铍寒篁惘犸惘舶脖洳爱沆贳犸惝舶脖洳拜霄弪犰狃痱镝汨躞磲镦埒麸泔铘孱趔狍躞踽飚物蝽犰禊麇泔蹯牾篝篝矧翳斌犷镯轸翳弪矬怩翳轶痱镡戾栳箴邈獒泔铙殇弪狒轱狎秕钿深骈铋豉族篝狎鏖翳犷轭骈铋翦怙狎镦溽螂铄篌犷睐轭瘐⑨扃矧轸桧趱蝾犷骢祆溽螂篑踽蝈镱ㄩ钿屮轶啵喋犷骢祆扉玷篑踽蝈镦ㄩ钿屮当轶喟喋项镤轸弪狒轱铙翳怙狎鏖祆忮轭骈铋翦禊怛殓梏项弼孱轭骈铋翦禊溽螂涉翳痱镡戾狍脲骘镤轸弪狒轱铙泔蹯趄徙翳怙躅溴溽螂篑踽蝈蟋怩箝钽翳妁镱禊狍骘弼孱轭瘐骚祆箅轲翳狒犷汨遽鏖翳翳噫殄熹鲠祯忮祜鳟澡轶轶犷轭骈铋翦泫沆蝈痱弩孱糸铉麒狒翳秕趔腴螋祜镫扉脲狒翳糸礤垠秕蜚瀣沆镪躜遢ㄤ彐珈痂决犰埽鼙墚馨ㄤ彐疳蝮圹犰顼篝轫绛篝蜉戾坶礴扉铄篝虔箴扉舡扉铄轫绛篝颟红秣鸿ㄣ秕铘轫绛扉铄螬烘殄熹ㄣ沆圮鼙荸洪礴ㄧ蜷浏怩殪洵珧殇轫绛扉铄珈痂决犰横扃磲瘀珈痂决犰犰顼篝颟┅阻孱汨邈腴铉骘篚蝌秕钿轭鲠祯弩殒轸秕镦怙躅潴轸疳螋镦翳轭骈铋翦骈屐洚垠秕蜚瀣沆镪躜遢ㄤ彐铄鳝鲠坩扃轫祜溴驷蹯糨戾垤镢ㄧ蜷浏铄殓桠矧泔矧潴祜ㄧ蜷浏狎遽溴祠狍暴┹ō揪祜泱磲（珏轫溴驷蹯舂蟓鹃铘博ㄧ弭犰顼┅┅阵豉痖汜篝屦骢钽糸镱骘轸弪狒轱町冕汨轭翳沲蝌孱蜥铉屮趄屙轸殄轭囔秣犷噼猷筢鲥忾镦糸礤垠秕蜚瀣沆镪躜遢ㄤ彐篝屦埯弘妁垤秣栝轫犰顼骈屐漭横篝狒妪戾垤秣ㄤ邈祜鳗栝ㄩ钽栝箴犷蜥铉祜栝祜泱ㄦ矧埒箴犷箴犷埒荸蝈漉沐ㄦ垠翎翦祜爿ㄡ篌镢轭篝狒酆轫祜爿铄鳝鲠犰顼轫祜ㄦ轵篝骈屐洎┅ō篝狒ㄡ篌镢红秣祜鳗ㄡ篌镢鸿栝躔溽翦烘殄熹蝈篝┅祜泱┅ㄤ彐箫祧坶铕豸钶ō揪疳蝮轭瘐舂ㄩ翦蜥翦篝屦铘瞟洪礴ㄦ殪翦颦鲠祗｛鼙泔躅舂澡轶轶痱弭豉箪秣ǖ骘疳螋镱睐磲汨轭濠义痨徙轭翳啜轸弪狒篝屦篝狒濠鏖翳祜镳秭弪趄犷箝孱箬秕熹忮眭汨驷篝弪浇扉铍寒篁惘犸惘舶脖洳碑沆贳犸惝舶脖洳陛深扉铄鏖翳睐顼犰镦忮轭徕戾麸遽箝禊痱镤蹉鲩篚犰辁狒轱铙狯镩蝈沲蝮轱ㄡ钿翳躞骘蝈顼礤盹辁狒轱忮铄骈趔麸磲脲灬躔溽翦骢钽糸镱躞徕戾鏖翳嚅翦蜥翦喈婶黠蹯漕忮痱徙糸汜麸珏铄蜥扉翳赭栳祧弩镦痱镡戾箝钽麇滹瞌铄邃犷泔钽屦镦趱蝾轭疳螋伯篝狎翦鏖翳泫沆弩骘轭骈铋翦溟蝻祆犷铄痨狴弪ㄩ瀹啜溴驷脲浔鞍ㄣ沆蜥铉卑暴┅怩汨犷珏翳屙秕麸骢钽糸镱骘遽箝弪溴怩珑轭绠垠秕蜚瀣沆镪躜遢ㄤ彐溴翦蝽轭轶糸悱溟埕躜钶ǐíㄩ钽í趱蝾┅┅躞邃睐铄囗镤编骢钽糸镱徵衢町垠秕蜚瀣沆镪躜遢ㄤ彐徜鲠钽瀛痫垓镬痫筝盹洵ǐ蝻祆痫螬卑┅澡徙糸鲥痨狴弪轶麸珑戾洮犷躞邃狍翳轭溴镦轸屙麸躔溽翦垠秕蜚瀣沆镪躜遢ㄤ彐徜鲠钽瀛篝狒埯弘妁垧矬筱矧弩痨狴弪横篝狒妪蝻祆戾垲鬻痫ㄡ漩犷沐痫蝻祆ㄧ弭痫痨狴弪┅ō篝狒躔溽翦轭酆筱矧弩痨狴弪铄鳝痫螬ㄡ篌镢轭酆痫痨狴弪铄鳝痫螬ㄡ篌镢吼灬弪盹ㄩ钽痨狴弪博┅┅ㄤ彐痨狴趱蝾埯弘妁埕躜痫痨狴弪溟瀛骖横玑礤ō玑礤ㄡ漩犷沐篝狒ㄤ殄骖趱蝾┅躔溽翦呼躜轭悌┅扉脲翳蝈徜徕殪轸镦躞轭囗邃戾泔蝈骈钿骈蝮羿麸篝镳轸弪狒轱町垠秕蜚瀣沆镪躜遢ㄤ彐疳螋坶铕豸ō揪轭瘐磲脲玑礤溴翦蝽轭轶糸悱溟濠ㄩ翦蜥翦痨狴趱蝾ㄦ轭洵骈蝮疳螋獒鏖铑弪卑鞍┅骈钺飙筱矧濠嗅螋躞弩筢礤轸弪狒轹狃痱镝汨麒殂轶眭汨箪秣弪碑搀迈翳轶玳鲥躞翳骢祆篝狒狒弼弪糸礤糸汶轭灬箦聃孱沐骘鲩垠秕蜚瀣沆镪躜遢ㄤ彐溟蜥悱蝻祆⒃桢痫篌殁戾秕翥镯弩怡骝羼蹂钽镦充钞ㄦ蝈聃孱汩弩ㄦ矧垓郾齿虿郾齿虺郾齿ǐ虮虿虺┅┅ㄤ彐溟蜥悱痫篌⒁弭躜磲镦翳痫篌殁戾秕翥镯篝狒弩鏖翳翳彘骝羼蹂钽忉箦镱弼弪痫篌殁殪轸镦充蝻祆垠翎翦钶蝈漉沐ㄦ垠翎翦栳箬垓镬骝羼葺礤蜱瀛鏖翳篝狒瀛栳箬ㄨ狍璀磲ㄡ漩犷沐篝狒篝狒蝻祆í骝羼┅┅溟蜥悱蝻祆螬ㄤ彐篝屦溟蜥⒘漩犷沐翳篝狒镦翳溟蜥黠蜢怡糸礤糸汶澡轶躔溽翦犰镦秕沲蝌孱篝狒弩轭麸翳彘骘祆秣轭篝狒弩轭镱疳篌篚轸徕戾骘嚅翦蜥翦喈埙轭筱矧黠蜢漭蝈漉沐ㄦ埙矧熹垠翎翦钶戾埯鸨鸩蝈磲轭铋忑ō揪ㄤ轵徙痫篌篝狒瞟ㄧ蝻躔怡（鏖铑弪鏖瞽筱矧脲ォ┅┹ō黠蜢躔溽翦轭酆鏖铑弪拜蝈漉沐磲箦泔钿鸨┅躔溽翦轭酆鏖铑弪陛蝈漉沐磲箦泔钿鸩┅躔溽翦后翎翦栳箬溟篌镢篝狒濠躔溽翦后翎翦栳箬（礤蜱瀛鏖翳ㄩ铘蝈磲轭┅┅┅黠蜢ê篝狒瀛栳箬黠蜢洎┅族翦蝽轭狒麒孱翳弪狎铒盹蝈篝狒弩翳狒狎孱鏖铑弪螽垠秕蜚瀣沆镪躜遢ㄤ彐疳螋坶铕豸ō揪磲脲溟蜥轭瘐舂ㄩ翦蜥翦疳螋獒篝屦溟蜥脖┅ㄦ轭洵骈蝮（屙痿ê篝狒瀛栳箬ォ┅瑚轭铄蝮蝈漉沐磲┅浇扉铍寒篁惘犸惘舶脖洳伯沆贳犸惝舶脖洳草祜镫邃狒翳溽翎犷筢翳赭栳祧弩沲舣疳篝轭翳镡鲩秕骈蝮箦泗轱麸铒铄邃沆犴痖铉骢钽糸镱犷珏疳螋聃殂腱躞轭钺轹箦镦沲蝌孱綮扉泔矧溟钺翦螽澡轭瘐麽箜犰孱秕玷骑疳螋翳轶黠蹯漕黠螂弼孱鏖翳忾麴徙腴铉轸轶月麸篝矧翳钺轹箫祯糸镱箫麇汜瞌趄徙轭溟鲩漉犰祜汜糸镱螽黠螂邃秕翳材汜箦镱疳疱麸戾狎翳犰顼蜷翳憩麒殂轶麸蝈沲蝮轹屐蝈盹鲥犰秭弪灬痧轭篚忏踱弩骝镯遽汨灬弪镦翳轭篝蝓泗轱铙骑э瞌沲忮蟋麇徜翳彘躅轳蹂鲲祯礤骑э骀沲忮蟋翳妁徜扉玷趔怩篝殪珏蝈盹鲥骝镯沲忮忮骘蝈翳屙澡弩赭祜戾鲥豸殪轸殄滹盹篝镦翳黠螂麸骈钿翳秭弪灬痧轭狎遽镦赭沲怙殇螽垠秕蜚瀣沆镪躜遢ㄤ彐沆犴⒁弭躜翳泔矧溟钺翦蜥铉帏班帏编沆犴疱麸蜥铉囔镟噼猷义趱蝾铋轭翳汜箦镦铒秭弪灬甬圹祜栝埒陛麒孱ㄡ钿冀祜暴窘栝癌郇磲祜癌黹栝暴荸ㄤ彐秭弪灬⒁弭躜翳沲怙殇轭翦蝮邈糸镱镦嚆编犷嚆侧屐箦铋飚坫悴戾垓弩蹯磲沆犴惚悴┹麒孱ㄥ鲥蝙殇孱糸豉蝈篚祠蝈篚祠┅澡泔蝈镦翳犰顼蜷翳轶翳轶蝈沲蝮轹礤翳镤麸骈钿翳鲲祯礤镦扉玷趔躅轳蹂禊蝈痱弩孱翦怡翳轶沲忮怡篚怍蜥泗轭秕翳鲲祯礤镦秭弪灬痧轭沲忮轭灬翦轭篝蝓泗轱铙燥磲脲篚蝈麇滹铒篚怍蜥泗翳筢礤鲲祯礤赭殂矧盹蝈┈麇铄邃麸溴筱孱翳孱糸蝈趄邋蝈沲蝮轹屐怙蝌秣邃翳灬箦圄衢祗骝镯柔箅屐麸屐彗犷綮珏翳箦镦蝈磲轭轭泔礅轭狒轱铙麸泔铙殇弪轭屐彗犷綮躞噔豸灬篝麸痱弼孱铋汨邈塍轭溴篝蝓泗躜轭绗箝钽翳灬篝轸屙镦翎殪轶Ж┊垠秕蜚瀣沆镪躜遢ㄤ彐躅轳蹂鲲祯礤⒁弭躜翳鲲祯礤躅轳蹂麸嚆踱镩溧义沲蝮轹屐蝈盹鲥鲲祯礤躅轳蹂禊桢熹怡篚猸沲怙殇骝镯翳矬翳狒秭弪灬嚆踱镩溧坫踱镩沲怙殇筝戾垓屐弼犷舡沲怙殇脲屦（秭弪灬沲怙殇ォ沲怙殇螬蝈漉沐ㄦ埕雉犰埕栝篚忏踱镩潴葺ō麸翎躅轳蹂鲲祯礤翳轶篚忏踱镩潴┅鲲祯礤沲怙殇ㄢ豸灬篝翎殪蝈戾鲠铘沲怙殇螬┅┅浇扉铍寒篁惘犸惘舶脖洳串沆贳犸惝舶脖洳摧昧赵上魏孱觑邃翳徼帷盹礤铘镦翳轶瘐戾歪觑箴镩戾蝮徼遽洚婶黠螋骈珲蜷铉镱秕秣町语礤糸礤骚祆腴汶镦怛豸骘蜚箦狎汨麒殪骈珲蜷铉秕翳镳糸磲礤翳镤迈鏖翳箦狎汨箴徙镦篝屙痕卑薇摧翳狒麽铄鲥顼轭麸黠螂语轭麸翳溽翎麇顼浇镶箦蝣狒轱铙泔蹯箦翳贝箦泗轱铙镱骘遽汨轭瘐舂溟骀弪邃镱禊镱扉铄蠛春噤轹爆捕麒殂灬忮噤喋岛噌滗奸铘距灬忮祆邃噌喋钡噌滗奸铘距灬忮祆邃噔喋噤泔鲠蜷弩鏖翳噌喱箫麇滹瞌铄邃麸趄徙轸ㄠ溧轶犰麽殒噌轶痫箝糸鲥轭翦珏颥屐箦捕┊族ъ汜祆遽汨轭瘐篝屙痕磉檩骘㈨镤屐篷踽糸镱屙忮滗邃轭翳犰顼蜷翳愍歪翥韬篝屙痕磉擗榄暴盹捕徇檩彭忾珑孱轭绾篝屙痕唛捕擗榄暴磉膺檩予蜷铍蹯狒轱詈篝屙痕唛骒镲颞擗榄暴捕┹领箫圜轶铄鲥盹溟骈邃轸镱禊珏趔翳沲蝌孱轭瘐帏犷帙狎弪镥秕狒翳篝狎镦遽汨蝓帔轶翳徙沲祯磲麸帏轶彘翳弪殒翳弪轶歪翥璎屐箦碑噌轶铄鲥骝镯杯宫箫铒痫箝糸鲥噌汜蝈篚祠轭歪翥篝屙痕亮ú盹捕拜澡弪彐矧翳弪狎赭翳轭珞翳狒汜栳痧孱碑铒歪翥ㄡ供帔珏趔彭忾珑孱邃碑歪翥ㄡ暴帔珏趔予蜷铍蹯狒邃骑帔麸忮弪徭翦贝蝓铙翳弪铄邃麸忮犷羼踽铛礅弪镦屙忾珑孱轭珞犷箬蜷铍蹯狒轱铙骑睐轭瘐衄翳轶礤犷犰痫篌殁戾磲翥桢狎磲翥桢螽项麸翳泔溴族镱禊汜蝈徕秕噌犷噔喱箫汨弪蝙痖汶翳屙骝镯翳轭瘐舢垠秕蜚瀣沆镪躜遢ㄤ彐疳蝮坶铕豸ō揪轭瘐疳螋轸轱备磲牾（铘旦（铘钡┅磲疳螋獒狃痨篝颟磲篝蜷铉豸殪轭趔┅浇隋殇遽蛮篝屦痖铉翳蝻蹒翳溽翎泔蹯箦翳狒屙忾珑孱轭蝻祆躔翳痱弼轱躞帔轭箝溴眭祠轲扉汜糸镱鏖翳捕麒殂栝溴轸镱沐盹捕镢沲蝮犷徜潴轭铄轭骘蝽狒轱詈篝屙痕磉膺檩予蜷铍蹯狒轱溴篝蝻翳狒灬篝忾镦铄轭骘怡溟鲩溟铉怡捕犷趄躅汜糸铉犷箝眭祠犷屣躞禊屮痫箦翳灬篝轭骘蝽狒轱徜溴洚贤轸篝徙氍麒狒珧遽瘐戾垠秕蜚瀣沆镪躜遢ㄤ彐溴舡溟玳舡蝈祗⒁弭躜铙泔祆邈糸镱镦噗楸椴钶趱痨弩麒弪囝轶翳溟骀弪孱沐忮赭邋翳赭轭溟沐嚅编嚅侧镦翳盹溴铛礅弪垆狒彷祜镳垆狒溽翎篝徙圯蝈祗圯ㄩ姝戾圹廨ㄦ轵篝溽翎┹ㄣ镱岍蝈沲铄溽翎ㄩ钽椹ㄣ镱篝徙坶廨蝈祗岍戾圹榘獍疱咫篝徙氅蝈沲铄溽翎ㄩ钽椹痫篝徙氅ㄣ镱蝈祗坶榘ǐ獍┹┅┅蝈祗┅组翳翳腩秣溟骀弪孱沐忮赭邋铛礅弪疳轵蟋翳轶骢钽糸镱骈钿翳轭翦珏疳轵翳狒筢糸箧殄翳磲宫黹翎蜱弭镦疳螋犷伯垠秕蜚瀣沆镪躜遢ㄤ彐蝈飙绢蹴⒁弭躜铙趱痨镦赭溟玳趔坩廨麒弪溟骀镱镦矧轶翳翎蜱弭犷怙翳铛礅弪狎骝镯杯竟瀹绠蝈飙绢蹴穿骄鄣馆蝈飙绢蹴博骄酃份蝈飙绢蹴旦骄郾遁埕狎珏溟骀ㄩǐ翎蜱弭溟骀卑郇翎蜱弭溟骀翎蜱弭埕狎珏ō翎蜱弭溟骀┹┅ㄤ彐怩殪洵盹溴⑵矧玳鲥圄狎珏羿铛礅弪ü殒麇蝈趄轭骘栝玷弩衄骘祜麇篝┈犷疳轵鏖箦溟玳蝈灬糸镱囹屐筻泔祆邈糸镱镦垆浔溟骀趱痨弩蝈趱蝾翳盹溴铛礅弪翳狒骈趔犰溟玳蝈灬糸镱蟋趄孱溟铉麸麽蜾翳翎蜱弭埕狎珏蝈祗蝈漉沐ㄦ垲坶楸溟骀葺戾圹霭霰蝈飙绢蹴翎蜱弭溟骀┹ㄡ篌镢榘霭楸霰┅鲥蝈疱狒贝癌蝈祗┅ㄤ彐箫祧坶铕豸翎蜱弭ō揪疳蝮轭瘐舂溴舡溟玳舡蝈祗ㄢ蹰熹盹溴翎蜱弭ㄡ痧禊篝颟┅ㄤ彐疳螋坶铕豸箫祧轭瘐供ㄤ彐疳螋坶铕豸箫祧轭瘐暴浇扉铍寒篁惘犸惘舶脖洳诞沆贳犸惝舶脖洳递郁蜥殓梏骘蝼狎蝈躞镦圜蜥瓠泔矧潴麸骈钿犷忪镢脲蝮轭翦铘轱钺祆躞邃噤轶箫汔犷噌篌镢忮汜躞翳秕玷骚篦轸汨麸翳趄犷箝孱鲥蝮轱铙灬翦轭祜镳蝈沲骘箴邋洚垠秕蜚瀣沆镪躜遢ㄤ彐箬殒垆澌珧殇垤镢爿戾垲鬻祜ō揪祜ㄧ蜷浏鲥泗矧徜ō句屐翎悌ㄧ蜷浏黩狃泔矧潴澍澌┅ㄩㄧ弭珧殇铄鳝祜悌ōㄤ轶箫祜悌ㄡ篌镢铄鳝祜悌┅┅澡轶轶睐骈蝮躞镦噌蟓距犰麽翳秕玷轸镡骢筱狒轭绗怩扉脲轸桢蝈垠秕蜚瀣沆镪躜遢ㄤ彐篝屦垆澌珧殇ㄡ蟓珧殇蝈漉沐疳螋獒箬殒澍澌绌ㄦ殪翦颦鲠祗｛芫珧殇┅蝈漉沐疳螋獒箬殒澍澌绌ㄦ殪翦颦鲠祗｛荟珧殇┅┅澡轶轶蝈犰禊翳遽镦轸弪狒瀹栾疱蝈趱蝾麸翳弩鏖翳鲩篚犰辁狒轱铙垠秕蜚瀣沆镪躜遢ㄤ彐疳螋坶铕豸戾圹澍澌珧殇疳蝮轭瘐舂ō揪珧殇ㄩ翦蜥翦疳螋獒篝屦澍澌┅疳螋轸轱暴翎脲麒殪疳螋獒狃痨铒艚┅泔躅轭悌┅