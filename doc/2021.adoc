= Advent of Code 2021
:author: @tschady
:toc:
:toc-placement!:
:date: 2021 Dec 01
:description: Commentary on solutions to http://adventofcode.com/2021[Advent of Code 2021] problems
:sectanchors:

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

My running commentary on approach, with any code of interest.

== Rules for Sanity

1. Never stay up for problem release.
1. Don't sweat the leaderboard.
1. Finish puzzle and refactor before looking at other approaches.

toc::[]

== link:../src/aoc/2021/d01.clj[aoc.2021.d01]
The trick here is realizing that `(B + C + D) - (A + B + C) = D - A`.
I originally used the 3-arity version of map with
`(count (filter pos? (map - (rest input) input)))`
but then realized that was a utility fn I'd forgotten about: `intervals`, for
the speed competition I never enter.

[source, clojure]
----
(defn part-1 [input]
  (count (filter pos? (intervals input))))

(defn part-2 [input]
  (count (filter pos? (intervals 3 input))))
----


== link:../src/aoc/2021/d04.clj[aoc.2021.d04]
I used 2D arrays for cards and `nil` to mark numbers.
I thought `(group-by bingo?)` worked well, but the main point of interest is
the lazy sequence of recursive calls to `scores`. This sets up the elegant
`part-1`, `part-2` solution, which reads like the problem description.

[source, clojure]
----
(defn scores [[[num & nums] cards]]
  (lazy-seq
   (when num
     (let [{winners true remain nil} (->> cards
                                         (mark-all-cards num)
                                         (group-by bingo?))
           win-scores (map (partial score num) winners)]
       (concat win-scores (scores [nums remain]))))))

(defn part-1 [input] (first (scores (parse-input input))))

(defn part-2 [input] (last (scores (parse-input input))))
----


== link:../src/aoc/2021/d05.clj[aoc.2021.d05]
I use slope and y-intercept to compute points on the line. The interesting part is
use of Infinity: `##Inf` which works well mathematically, but does require the occasional 'if'.

[source, clojure]
----
(defn- slope [[[x1 y1] [x2 y2]]]
  (if (= x2 x1)
    ##Inf
    (/ (- y2 y1) (- x2 x1))))
----


This lets me describe horizontal/vertical/diagonal lines by their slope.

[source, clojure]
----
(defn part-2 [input] (solve #{0 ##Inf 1 -1} input))
----


== link:../src/aoc/2021/d06.clj[aoc.2021.d06]
Simple `iterate` on an 8-element vector of rolled-up fish counts per time.
I saw some solutions that completely destructured the `timers` vector.
This is clever - I never think of it - I don't know why.

[source, clojure]
----
(defn next-gen [timers]
  (let [spawners (get timers 0 0)]
    (-> timers
        (subvec 1)
        (assoc 8 spawners)
        (update 6 (fnil + 0) spawners))))
----


== link:../src/aoc/2021/d07.clj[aoc.2021.d07]
Like many of these AOC problems, a HOF is a clean way to separate part-1 and
part-2 formulas.

[source, clojure]
----
(defn total-fuel
  "Returns the total fuel used by all the crabs at locations `locs` to reach point `dest`,
  using function `f` to compute fuel required for each distance."
  [locs f dest]
  (reduce + (map (comp f #(Math/abs (- ^int % ^int dest))) locs)))
----


For part 1, because the costs are linear with distance, we know the median will be the meeting point.

[source, clojure]
----
(defn part-1 [input]
  (total-fuel input identity (m/median input)))
----


For part 2, if the fuel formula was `n^2` then the mean would yield the exact answer.
But since formula is a triangle number, which is always less than the square, I first used the mean as an upper bound to reduce the search space.
Then I found
https://www.reddit.com/r/adventofcode/comments/rawxad/2021_day_7_part_2_i_wrote_a_paper_on_todays/[this beauty]
which shows the answer will be within 0.5 of the mean, so I test the 2 integers around it.

[source, clojure]
----
(defn part-2 [input]
  (let [mean (m/mean input)
        low (int (Math/floor mean))
        hi (int (Math/ceil mean))]
    (->> (range low (inc hi))
         (map (partial total-fuel input m/series-sum))
         (apply min))))
----


== link:../src/aoc/2021/d08.clj[aoc.2021.d08]
For this problem I used a combination of expected frequencies of the whole,
and differences between the characters.

- we recognize 1,4,7,8 from their unique string sizes
- we know {b e f} from their unique freqs in the full set of numbers
- we know {a} from diff of 1 and 7
- we know {c} because it's the unknown remaining in 1
- we know {d} because it's the only unknown left in 4
- we know {g} because it's last

I also wrote a handy string diff function that returns a 3-tuple of [only left, only right, common] modeled after `core.data/diff`

[source, clojure]
----
(defn determine-output [[digits outputs]]
  (let [[one seven four & _] (sort-by count digits)
        all-freq (frequencies (apply str digits))
        b (key-for-val all-freq 6)
        e (key-for-val all-freq 4)
        f (key-for-val all-freq 9)
        a (ffirst (diff seven one))
        c (ffirst (diff one #{f}))
        d (ffirst (diff four #{b c f}))
        g (ffirst (diff "abcdefg" #{a b c d e f}))
        subst-map {a \a b \b c \c d \d e \e f \f g \g}]
    (->> outputs
         (map (comp alphagram (partial replace subst-map)))
         (map #(.indexOf all %))
         str/join
         Long/parseLong)))
----


== link:../src/aoc/2021/d09.clj[aoc.2021.d09]
A straightforward problem.  Notably, I was able to reuse my `grid` library
to build the grid, find neighbors, and create the graph in the form of an adjacency map.

[source, clojure]
----
(defn part-2 [input]
  (let [grid (g/build-grid input #(Character/getNumericValue %))]
    (->> (filter (partial low-point? grid) grid)
         (map first)
         (map (partial g/connected-adjacency-map (partial basin? grid) g/neighbor-coords-news))
         (map count)
         (sort >)
         (take 3)
         (reduce *))))
----


== link:../src/aoc/2021/d11.clj[aoc.2021.d11]
The core `step` function used in `iterate`.  By iterating, we do not need to
track any intermediate state like the zero count since we can sum over all the
states reached.

[NOTE]
====
My approach to these problems is to start from the outside in.  In this case,
I typed `(reduce flash grid flashers)` before anything else.
====

[source, clojure]
----
(defn step [grid]
  (loop [grid (transform [MAP-VALS] inc grid)]
    (if-let [flashers (seq (filter #(> (val %) 9) grid))]
      (recur (reduce flash grid flashers))
      grid)))
----


== link:../src/aoc/2021/d12.clj[aoc.2021.d12]
This problem immediately looked like a recursive Depth First Search.
For part-1 I could track the typical visited nodes and remove them from
the next search level, but interestingly part-2 flipped this on its head
and used a variable count.  This could be tracked with an extra boolean
like `bonus-used?`, but I preferred to put this complexity in the data layer
with the allowances map below.

[source, clojure]
----
(defn dfs-paths [g goal path allowances]
  (let [curr (peek path)]
    (if (= goal curr)
      (vector path)
      (let [nexts (filter #(pos? (get allowances %)) (get g curr))]
        (mapcat #(dfs-paths g goal (conj path %) (update allowances curr dec)) nexts)))))
----


The interesting part of the algorithm is this map of the number of times
each cave may be visited.  I use infinity again for large cave count since it can be decremented forever.

[source, clojure]
----
(defn make-allowances
  "Returns map of cave to number of times it may be visited.
  Small caves begin with lowercase and can be visited once.
  Large caves (everything not small) can be visited infinitely."
  [g]
  (let [{small true, big false} (group-by small-cave? (keys g))]
    (merge (zipmap small (repeat 1)) (zipmap big (repeat ##Inf)))))
----


I optimized for dev time and DFS algo simplicity here, by iterating over
the collection of small-caves, treating each one in turn as
the magic cave that can be visited twice.  There is a lot of duplication here,
with many paths visited multiple times then collpased with `set`.

[source, clojure]
----
(defn part-2 [input]
  (let [g           (parse-graph input)
        init-allow  (make-allowances g)
        small-caves (remove #{"start" "end"} (filter small-cave? (keys g)))]
    (->> small-caves
         (map #(update init-allow % inc))
         (mapcat (partial dfs-paths g "end" ["start"]))
         set
         count)))
----


== link:../src/aoc/2021/d13.clj[aoc.2021.d13]
Great use of specter here to perform a complex conditional mutation.
Thanks to @drowsy for the idea

[source, clojure]
----
(defn fold [paper [axis v]]
  (set (transform [ALL (if (= 'x axis) FIRST LAST) (pred> v)] #(- (* 2 v) %) paper)))
----


== link:../src/aoc/2021/d14.clj[aoc.2021.d14]
For part-1, I raced to an iterative solution building the string each time with
`medley.core/interleave-all`.
10 iterations took 20ms, 20 took 1000x that, so there's no way we can do this 40 times.
Looking at the ruleset, it's pretty contained, so we should be able to just track
counts of each pair.  Very similar to day 6 for fish count.

[source, clojure]
----
(defn step [rules pair-counts]
  (reduce-kv (fn [m [a b :as k] v]
               (let [insert (get rules k)]
                 (-> m
                     (update [a insert] (fnil + 0) v)
                     (update [insert b] (fnil + 0) v))))
             {}
             pair-counts))
----


The only thing of interest here is `x-nth`, a utility function I wrote that just
reverses the arguments of `nth` in order to make thread-last work.

[source, clojure]
----
(defn solve [input n]
  (let [[orig rules] (parse input)]
    (->> orig
         (partition 2 1)
         frequencies
         (iterate (partial step rules))
         (x-nth n)
         (assemble (last orig))
         score)))
----


== link:../src/aoc/2021/d15.clj[aoc.2021.d15]
First graph problem of the year.

[IMPORTANT]
====
(Is your https://www.reddit.com/r/adventofcode/comments/k3q7tr/my_advent_of_code_2020_bingo_card_fun_little_side/[AdventOfCode bingo card] complete yet?)
====

You *could* type out Dijkstra's algorithm, using Java's PriorityQueue
or `clojure.data.priority-map`.  Or, you could just slam it all into
a graph library and Keep 'er Movin'.

My go-to for these is https://github.com/Engelberg/ubergraph[ubergraph].
There was some ambiguity in the constructor for edges
(since the nodes were also `[x y]` vectors),
so I had to build an empty graph and use the explicit `add-edges*`

[source, clojure]
----
(defn edges [risks]
  (for [loc      (keys risks)
        neighbor (grid/neighbor-coords-news loc)
        :let     [risk (get risks neighbor)]
        :when    (some? risk)]
    [loc neighbor {:weight risk}]))

(defn safest-path [risk-grid start end]
  (-> (uber/multidigraph)
      (uber/add-edges* (edges risk-grid))
      (alg/shortest-path start end :weight)))
----


Part 2 is solved the same way after expanding the grid.
My new `mod-1` function helps prevent off-by-ones with 1-based indexing.

[source, clojure]
----
(defn expand-grid [grid magnifier]
  (let [[width height] (grid/size grid)]
    (apply merge (for [loc (keys grid)
                       dx   (range magnifier)
                       dy   (range magnifier)
                       :let [[x y] loc
                             risk (get grid loc)
                             new-risk (mod-1 (+ dx dy risk) 9)]]
                   {[(+ x (* width dx)) (+ y (* height dy))] new-risk}))))
----


Expanding the grid with size 1 for part-1 in an expensive no-op,
but I'm a sucker for generalizing the two parts.

[source, clojure]
----
(defn solve [input magnifier]
  (let [g (-> input
              (grid/build-grid #(Character/digit % 10))
              (expand-grid magnifier))
        end (mapv dec (grid/size g))]
    (:cost (safest-path g [0 0] end))))

(defn part-1 [input] (solve input 1))

(defn part-2 [input] (solve input 5))
----


== link:../src/aoc/2021/d16.clj[aoc.2021.d16]
This problem was tedious and painful.  I considered BNF parsing
(but the branching is pretty complex), and Java ByteBuffers,
before just settling on plain old Clojure.
The _only_ thing I like about this code is my use of `cl-format`.

[source, clojure]
----
(defn hex->bits [hex]
  (cl-format nil "船О漫磲（描狎徙翦虔溟玳倍桢┅娱钽犰翳轶溽翎轶轫眭翎忪瀣犰镦翳弩囿扉沐骖翎脲轭篝蝈犴犷蝈趱蝾趱痨镦翳翎蜱弭鲠祯犷翳篝蝈犴鏖翳翳翎蜱弭蝈盹鲥洚娱眭灬翦溴篝蝓泗轹汨镯痖铉怩轸轶徕箫祯翦禊铒骢町垠秕蜚瀣沆镪躜遢ㄤ彐箪殂瀛鲠垲篝蝈犴戾圹篚怅篝蝈犴箴扉舡狒篝蝈犴┹郇蟓鹃铘篚怅篝蝈犴荸囗邃戾泔蝈翎脲躔麸筢鲥箫礤糸礤腩秣轭麒孱麸篝镳汨镯痖铉翳忾趔垠秕蜚瀣沆镪躜遢ㄤ彐箪殂瀛扉翦蜥垠趄遽磔戾埚犰疳螋ō揪篝蝈犴疳螋轸轱旦翎脲躔麸（馨ㄦ轵篝ォ┅篝蝈犴ㄤ蝻ㄣ秕铘ㄦ灬趑孱鲠飙疳螋┅篝蝈犴鲠祯ō揪鲠飙疳螋磲疳螋獒潋镳暴骒狒翦蟓鹃铘博┹埚犰蹂篝蝈犴荸澡磲轭祜镳轶纤垠秕蜚瀣沆镪躜遢ㄤ彐疳蝮瀛疳汶弭垠趄遽磔戾圹鲥蝮轱篝蝈犴箪殂瀛鲠篝蝈犴埕疱篝蝈犴箪殂瀛鲠篝蝈犴垧狴祜徜篝蝈犴ㄣ狍豉疱箪殂瀛扉翦蜥篝蝈犴箪殂瀛镳弪狒矧篝蝈犴┅埯忽弪箝镱鲥蝮轱呼疱豉疱吼狴祜徜疳祜徜篝蝈犴荸歪痧轭麸骢钽糸镱磲脲翳泔溴蝈徜徕戾垠秕蜚瀣沆镪躜遢ㄤ彐豉疱撅黹磲（殒ケゲ癌（殒ケゲ癌（殒ケゲ癌ㄤ彐弼犰踽翦埯弘妁埕疱疳祜徜蔟ㄩ豉疱疳祜徜蝈漉沐豉疱撅豉疱磲弼犰踽翦疳祜徜┅┅浇扉铍寒篁惘犸惘舶脖浔樊沆贳犸惝舶脖浔份王汨盹蝈骢痱镡戾怼惋蝈翳轭腴铉戾篌豉痖铉骑疳螋爆麇腩秣翳痱镡鏖祆蝈趱蝾麸屮徙綮帙桨狒箫礤圄忮汜躞镦簌眄弭蝙箫翳磲鲥祜汩豉鏖祆忮麒狒弼弪忉蝈禊骈趔轭翳怙狒翳铄篝屦垠秕蜚瀣沆镪躜遢ㄤ彐疳螋圹咻箦蜷弩篚ㄤ邈ㄍ狒璇徕癌┅洛汜躞澍漪薏轶篝屦骢钽糸镱ō爆翳孱篚滗孱禊癌麇箝眇扉纟怡汜痧轭麸麒孱盹糸镱篝镳螽轶豉痖汜飚韵南羼踽糸镱垠秕蜚瀣沆镪躜遢ㄤ彐鲽⒁弭躜翳轭轸獒狲轶鲥祜汩豉麸蝈徙痫轭帏狒糸礤圄喈洛汜躞翳鲥祜汩豉篝镳狒骘蝈鲥颥麇溴翦蝽轭翳狒糸礤鏖翳聃徜蜥糸骘蝽蹯犷汜蝈篚祠翳弪瀹埒糨戾埕喏ㄩ铘ㄍ狒璇蝻躅ㄦ轵篝聃徜蜥糸í┅┅黹暨鲽癌ǒǐí伯í舂í舂í舂┅ㄤ彐鳄⒁弭躜翳轭轸獒狲轶鲥祜汩豉麸蝈徙痫轭帙狒糸礤圄喈垸糨ǒǐǒí伯舂博ㄤ彐鲥飙蜥铉⒁弭躜铙翳蜥铉坼钿痫轭趔镦鲥祜汩糸弩翳狒骈轭翎蜱弭怙铒翦怡囵甙疬编躞轭鲥祜汩豉骢钽糸镱噫狒糸礤圄喈坻垧甙疬陛糨郇轭ㄍ狒璇沐殪ㄦ疬舂┅ㄩ钽ㄩ铘ㄍ狒璇骒镲ㄦ疬舂┅┹澡磲轭狃痱镝汨轶麸疳蜥礤趄辁秭弪圄喈澡轶轶沆矬邃麸箫礤磲圄麒殂麇汜汜煦蹯狒鏖翳翳聃徜蜥糸骘蝽蹯岙娱钽犷盹糸镱轶轭溴疱钿孱衄麇汜汜煦蹯狒翳鲥祜汩豉蜥铉弩翳狒疳篌翳蝻蹒翳翎蜱弭狒遽汨糸礤篝屦垠秕蜚瀣沆镪躜遢ㄤ彐舡磲垧戾垌狲ㄤ邈ㄍ狒璇徕皓┹ㄩ铘ㄦ轵篝聃徜蜥糸íㄩ钽í磲雯┅í皓┅┅ㄤ彐疳螋圹甙弑甙弑葺ㄣ秕铘箦ㄦ矧埕蜥铉ㄩ钽舡磲甙┅ㄡ痧禊蜥铉鲥飙蜥铉鲽埒甙弑舂ㄡ痧禊蜥铉鲥飙蜥铉鳄垸甙弑舂┹埒荸┅浇扉铍寒篁惘犸惘舶脖浔府沆贳犸惝舶脖浔篙往骈蝮翳秕玷麽彘翳弪圄蝈瀛箦襦矧嚆祜牾蝈轲喈组翳犰翳钺鲩玑糸铉铄沐篌狎麇铘鏖翳轲疱蝮领翳秕玷骚驷黹扉狎鏖翳翳屙骝镯泔铙殇弪轭翳彘躞镱痱弼轱躞遽蝮翳轶麽睐骈蝮徙趱犰痱镡戾鏖翳翳屙箫箴孱箫礤糸礤蝈徜轭绠澡孱泔铙殇弪徕戾屮疱蜷礤铘狒轱麸骈珲蝈秕翳钺鲩玑糸镱勖琳陨衔浇浇祜篝栾躜忮汜躞蝈徜翳轭篝蝓泗轱铙黩镱绠麽钺鲩玑糸铉翳蝻蹒翳趄邋骈钿轭翳骈蝮狯衢灬忪镳弪狒轱瞵翳孱滹轭轸澡轭篝蝓泗轱铙筢麸滹犰翳屮痨镤轭绗翳孱顼忉汶犷滹犷箴扉趑轭绠栳麸躞痱轭翩溴怩珑轭镱翳屮犴痨鏖翳黹铄鲶犷雉桢疱蝮镱箫祯糸镱麸箦麒弪麇铘黩镱绠浇浇秋趑祜鲥痱镡戾轭瘐翳狒钺糸鲥渺镪躜泔溴箫囹遽洵篝蜷铉牾篝黠螂螽垠秕蜚瀣沆镪躜遢ㄤ彐轭瘐磲瘀蝈徜篝蜷铉ㄦ殪瀛豸殪蝈徜扉铄⒉安悲浔府豇簪┅伍沐麸栳鲥翳溴痿犰镱骘翳蜷溴垠秕蜚瀣沆镪躜遢ㄤ彐瞽屮痨镤蹇垲镤遢ㄡ钿ㄣ镬炜轲铒溴铒溴┅ㄣ秕铘轲疳翳铒溴┅┅躞犷轸弪狒矧麸灬殪钺鲩玑翦翳趄邋轭翳箴邈殒殄溟蝈泗轱詈囝屮羿骘骘蝼狎浏蜷玷衄囵蝈鲟骘忉汶麽蜾蟑戾骠族铄邃麸轭沆蹁翳轶啜铒铋炜┅汨邈忮汜躞帔轲孱溧镱禊黠螂顼轭骘蝼狎潴阻孱麇顼忉汶麽蜾疳篝翳蝻雉囝殪轶秕翦蝽轭狒轭箝珙犰垠秕蜚瀣沆镪躜遢ㄤ彐轸弪轲埴轲疱篝屦骖ō揪轲疱ㄩ翦蜥翦篝屦骖翎脲麒殪（犷铒铋炜ォ铒轲孱淇ォ┅┅娱钽麇铄邃麸躔溽翦赭屐屙孱趔麇栳鲥麸蝈趱蝾忉汶麸翳轶铒溴镱禊殒麇躔溽翦翳戾骠镱瀹澡躞犷蹒禊腱蹁珏轭翳徜洵戾骠骢钽糸镱麸蝈趱蝾忉汶垠秕蜚瀣沆镪躜遢ㄤ彐屮痨镤埴轲疱蜉戾圹戾骠蜷玷糨轲铒溴轲疱颟ō轲疱轲蝈痨徙癌ㄡ滗戾骠戾骠ㄡ滗蜷玷蜷玷舂轲蝻雉┅ㄤ彐箴扉⒁弭躜铙翳轲疱鏖翳翳轶铒溴蝈痨徙邃怡铄汨殪铒溴澡汨殪潴鲠祯弩狎翳轭翦珏栳祧弩镦翳沲蝌孱鲠祯瀣鏖翳蝻躅溟铉顼轭麸翳蜷玷鲠祯瀹埴轲疱蜉戾垲轲铒溴轲疱颟戾骠聃雉博蜷玷ō戾骠┹ō轲疱轲蝈痨徙垤彐蜷玷糨轲蝻雉┅澡磲轭祜镳躞弩轸弪狒矧麸骈钿翳铄狯衢灬忪屮痨镤弪涉翳弪轶瞌镱瀣翳孱趄犷箴扉舢涉麇滹瞌箴扉衄翳孱麇蝈滹铄韵南澡轶轶沲蝌孱綮轭彐骈汩孱衄狍麇蝈钺鲩玑翦忉汶麸遽汨屮痨镤轭铒溴麒孱麇泔蹯牾篝滹犰翳屮痨镤弪轭趱蝾ǖ骘疳螋博垠秕蜚瀣沆镪躜遢ㄤ彐蝈漉沐箢衢垆狒彷戾埴轲疱ō溽翎轲鲥泗矧轲轸弪ㄩ翦颦轲轲疱轲铄舂ㄩ姝戾坼痨镤弪ㄦ轭洵骈蝮屮痨镤蹇轸弪┹蝈沲ㄥ痨镤屮痨镤弪┅ㄩ姝戾垠痨轸翦ㄦ轭洵骈蝮箴扉艨轸弪┹蝈沲箴扉箴扉趑弪┅轲蝻雉轲疱颟┅┅浇扉铍寒篁惘犸惘舶脖洳爱沆贳犸惝舶脖洳拜霄弪犰狃痱镝汨躞磲镦埒麸泔铘孱趔狍躞踽飚物蝽犰禊麇泔蹯牾篝篝矧翳斌犷镯轸翳弪矬怩翳轶痱镡戾栳箴邈獒泔铙殇弪狒轱狎秕钿深骈铋豉族篝狎鏖翳犷轭骈铋翦怙狎镦溽螂铄篌犷睐轭瘐⑨扃矧轸桧趱蝾犷骢祆溽螂篑踽蝈镱ㄩ钿屮轶啵喋犷骢祆扉玷篑踽蝈镦ㄩ钿屮当轶喟喋项镤轸弪狒轱铙翳怙狎鏖祆忮轭骈铋翦禊怛殓梏项弼孱轭骈铋翦禊溽螂涉翳痱镡戾狍脲骘镤轸弪狒轱铙泔蹯趄徙翳怙躅溴溽螂篑踽蝈蟋怩箝钽翳妁镱禊狍骘弼孱轭瘐骚祆箅轲翳狒犷汨遽鏖翳翳噫殄熹鲠祯忮祜鳟澡轶轶犷轭骈铋翦泫沆蝈痱弩孱糸铉麒狒翳秕趔腴螋祜镫扉脲狒翳糸礤垠秕蜚瀣沆镪躜遢ㄤ彐珈痂决犰埽鼙墚馨ㄤ彐疳蝮圹犰顼篝轫绛篝蜉戾坶礴扉铄篝虔箴扉舡扉铄轫绛篝颟红秣鸿ㄣ秕铘轫绛扉铄螬烘殄熹ㄣ沆圮鼙荸洪礴ㄧ蜷浏怩殪洵珧殇轫绛扉铄珈痂决犰横扃磲瘀珈痂决犰犰顼篝颟┅阻孱汨邈腴铉骘篚蝌秕钿轭鲠祯弩殒轸秕镦怙躅潴轸疳螋镦翳轭骈铋翦骈屐洚垠秕蜚瀣沆镪躜遢ㄤ彐铄鳝鲠坩扃轫祜溴驷蹯糨戾垤镢ㄧ蜷浏铄殓桠矧泔矧潴祜ㄧ蜷浏狎遽溴祠狍暴┹ō揪祜泱磲（珏轫溴驷蹯舂蟓鹃铘博ㄧ弭犰顼┅┅阵豉痖汜篝屦骢钽糸镱骘轸弪狒轱町冕汨轭翳沲蝌孱蜥铉屮趄屙轸殄轭囔秣犷噼猷筢鲥忾镦糸礤垠秕蜚瀣沆镪躜遢ㄤ彐篝屦埯弘妁垤秣栝轫犰顼骈屐漭横篝狒妪戾垤秣ㄤ邈祜鳗栝ㄩ钽栝箴犷蜥铉祜栝祜泱ㄦ矧埒箴犷箴犷埒荸蝈漉沐ㄦ垠翎翦祜爿ㄡ篌镢轭篝狒酆轫祜爿铄鳝鲠犰顼轫祜ㄦ轵篝骈屐洎┅ō篝狒ㄡ篌镢红秣祜鳗ㄡ篌镢鸿栝躔溽翦烘殄熹蝈篝┅祜泱┅ㄤ彐箫祧坶铕豸钶ō揪疳蝮轭瘐舂ㄩ翦蜥翦篝屦铘瞟洪礴ㄦ殪翦颦鲠祗｛鼙泔躅舂澡轶轶痱弭豉箪秣ǖ骘疳螋镱睐磲汨轭濠义痨徙轭翳啜轸弪狒篝屦篝狒濠鏖翳祜镳秭弪趄犷箝孱箬秕熹忮眭汨驷篝弪浇扉铍寒篁惘犸惘舶脖洳碑沆贳犸惝舶脖洳陛深扉铄鏖翳睐顼犰镦忮轭徕戾麸遽箝禊痱镤蹉鲩篚犰辁狒轱铙狯镩蝈沲蝮轱ㄡ钿翳躞骘蝈顼礤盹辁狒轱忮铄骈趔麸磲脲灬躔溽翦骢钽糸镱躞徕戾鏖翳嚅翦蜥翦喈婶黠蹯漕忮痱徙糸汜麸珏铄蜥扉翳赭栳祧弩镦痱镡戾箝钽麇滹瞌铄邃犷泔钽屦镦趱蝾轭疳螋伯篝狎翦鏖翳泫沆弩骘轭骈铋翦溟蝻祆犷铄痨狴弪ㄩ瀹啜溴驷脲浔鞍ㄣ沆蜥铉卑暴┅怩汨犷珏翳屙秕麸骢钽糸镱骘遽箝弪溴怩珑轭绠垠秕蜚瀣沆镪躜遢ㄤ彐溴翦蝽轭轶糸悱溟埕躜钶ǐíㄩ钽í趱蝾┅┅躞邃睐铄囗镤编骢钽糸镱徵衢町垠秕蜚瀣沆镪躜遢ㄤ彐徜鲠钽瀛痫垓镬痫筝盹洵ǐ蝻祆痫螬卑┅澡徙糸鲥痨狴弪轶麸珑戾洮犷躞邃狍翳轭溴镦轸屙麸躔溽翦垠秕蜚瀣沆镪躜遢ㄤ彐徜鲠钽瀛篝狒埯弘妁垧矬筱矧弩痨狴弪横篝狒妪蝻祆戾垲鬻痫ㄡ漩犷沐痫蝻祆ㄧ弭痫痨狴弪┅ō篝狒躔溽翦轭酆筱矧弩痨狴弪铄鳝痫螬ㄡ篌镢轭酆痫痨狴弪铄鳝痫螬ㄡ篌镢吼灬弪盹ㄩ钽痨狴弪博┅┅ㄤ彐痨狴趱蝾埯弘妁埕躜痫痨狴弪溟瀛骖横玑礤ō玑礤ㄡ漩犷沐篝狒ㄤ殄骖趱蝾┅躔溽翦呼躜轭悌┅扉脲翳蝈徜徕殪轸镦躞轭囗邃戾泔蝈骈钿骈蝮羿麸篝镳轸弪狒轱町垠秕蜚瀣沆镪躜遢ㄤ彐疳螋坶铕豸ō揪轭瘐磲脲玑礤溴翦蝽轭轶糸悱溟濠ㄩ翦蜥翦痨狴趱蝾ㄦ轭洵骈蝮疳螋獒鏖铑弪卑鞍┅骈钺飙筱矧濠嗅螋躞弩筢礤轸弪狒轹狃痱镝汨麒殂轶眭汨箪秣弪碑搀迈翳轶玳鲥躞翳骢祆篝狒狒弼弪糸礤糸汶轭灬箦聃孱沐骘鲩垠秕蜚瀣沆镪躜遢ㄤ彐溟蜥悱蝻祆⒃桢痫篌殁戾秕翥镯弩怡骝羼蹂钽镦充钞ㄦ蝈聃孱汩弩ㄦ矧垓郾齿虿郾齿虺郾齿ǐ虮虿虺┅┅ㄤ彐溟蜥悱痫篌⒁弭躜磲镦翳痫篌殁戾秕翥镯篝狒弩鏖翳翳彘骝羼蹂钽忉箦镱弼弪痫篌殁殪轸镦充蝻祆垠翎翦钶蝈漉沐ㄦ垠翎翦栳箬垓镬骝羼葺礤蜱瀛鏖翳篝狒瀛栳箬ㄨ狍璀磲ㄡ漩犷沐篝狒篝狒蝻祆í骝羼┅┅溟蜥悱蝻祆螬ㄤ彐篝屦溟蜥⒘漩犷沐翳篝狒镦翳溟蜥黠蜢怡糸礤糸汶澡轶躔溽翦犰镦秕沲蝌孱篝狒弩轭麸翳彘骘祆秣轭篝狒弩轭镱疳篌篚轸徕戾骘嚅翦蜥翦喈埙轭筱矧黠蜢漭蝈漉沐ㄦ埙矧熹垠翎翦钶戾埯鸨鸩蝈磲轭铋忑ō揪ㄤ轵徙痫篌篝狒瞟ㄧ蝻躔怡（鏖铑弪鏖瞽筱矧脲ォ┅┹ō黠蜢躔溽翦轭酆鏖铑弪拜蝈漉沐磲箦泔钿鸨┅躔溽翦轭酆鏖铑弪陛蝈漉沐磲箦泔钿鸩┅躔溽翦后翎翦栳箬溟篌镢篝狒濠躔溽翦后翎翦栳箬（礤蜱瀛鏖翳ㄩ铘蝈磲轭┅┅┅黠蜢ê篝狒瀛栳箬黠蜢洎┅族翦蝽轭狒麒孱翳弪狎铒盹蝈篝狒弩翳狒狎孱鏖铑弪螽垠秕蜚瀣沆镪躜遢ㄤ彐疳螋坶铕豸ō揪磲脲溟蜥轭瘐舂ㄩ翦蜥翦疳螋獒篝屦溟蜥脖┅ㄦ轭洵骈蝮（屙痿ê篝狒瀛栳箬ォ┅瑚轭铄蝮蝈漉沐磲┅浇扉铍寒篁惘犸惘舶脖洳诞沆贳犸惝舶脖洳递郁蜥殓梏骘蝼狎蝈躞镦圜蜥瓠泔矧潴麸骈钿犷忪镢脲蝮轭翦铘轱钺祆躞邃噤轶箫汔犷噌篌镢忮汜躞翳秕玷骚篦轸汨麸翳趄犷箝孱鲥蝮轱铙灬翦轭祜镳蝈沲骘箴邋洚垠秕蜚瀣沆镪躜遢ㄤ彐箬殒垆澌珧殇垤镢爿戾垲鬻祜ō揪祜ㄧ蜷浏鲥泗矧徜ō句屐翎悌ㄧ蜷浏黩狃泔矧潴澍澌┅ㄩㄧ弭珧殇铄鳝祜悌ōㄤ轶箫祜悌ㄡ篌镢铄鳝祜悌┅┅澡轶轶睐骈蝮躞镦噌蟓距犰麽翳秕玷轸镡骢筱狒轭绗怩扉脲轸桢蝈垠秕蜚瀣沆镪躜遢ㄤ彐篝屦垆澌珧殇ㄡ蟓珧殇蝈漉沐疳螋獒箬殒澍澌绌ㄦ殪翦颦鲠祗｛芫珧殇┅蝈漉沐疳螋獒箬殒澍澌绌ㄦ殪翦颦鲠祗｛荟珧殇┅┅澡轶轶蝈犰禊翳遽镦轸弪狒瀹栾疱蝈趱蝾麸翳弩鏖翳鲩篚犰辁狒轱铙垠秕蜚瀣沆镪躜遢ㄤ彐疳螋坶铕豸戾圹澍澌珧殇疳蝮轭瘐舂ō揪珧殇ㄩ翦蜥翦疳螋獒篝屦澍澌┅疳螋轸轱暴翎脲麒殪疳螋獒狃痨铒艚┅泔躅轭悌┅